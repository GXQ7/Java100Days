# Data Structures & Algorithms
- Recap on Data Structures and Algorithms alongside their complexity analysis (Sorting & Searching)

## Arrays
- an indexable, fixed size, collection of the same type in contiguous memory
- the size of the array must be known before creation
- other data structures can be created using array
- visual = spreadsheet
> Search, Insert & Deletion: **O(n)** Sorting: **O(n log n)** Access: **O(1)**

```JAVA
        int[] ages = { 18, 35, 42, 70, 81, 67, 12, 50, 38, 40, 33 };
        String[] colours = new String[4];
        colours[0] = "Yellow";
        colours[1] = "Orange";
        colours[2] = "Green";
        colours[3] = "Blue";
        System.out.println(Arrays.toString(ages));
        Arrays.sort(ages);
        int index = Arrays.binarySearch(ages, 67);

    };
```
## Multi-dimensional Arrays
- Java supports n-dimensional arrays (can be though of as an array of array)

### 2D Array Implementation 
- Stored in row-major order
- [row_index][column_index]

```JAVA
        int[][] cords = { { 2, 5 }, { 6, 7 } };
        System.out.println(cords[1][1]);

        // Row-Major Order : traversal occurs across rows
        for (int i = 0; i < cords[0].length; i++) {
            for (int j = 0; j < cords.length; j++) {
                System.out.println(cords[j][i]);
            }
        }
        // Column-Major Order : traversal occurs across columns
        for (int i = 0; i < cords[0].length; i++) {
            for (int j = 0; j < cords.length; j++) {
                System.out.println(cords[j][i]);
            }
        }
```
### 3D Array Implementation 
- an array of 2D arrays
- [array_index][row_index][column_index]

- visual = array_index = spreadsheet sheet
```JAVA
        int [][][] _3dArray = {{{4,5}, {6,7}, {8,9}}    ,    {{13,15}, {18,20}, {17,68}}};
        int seven = _3dArray[0][1][1];
        int eighteen = _3dArray[1][1][0];
        System.out.println(eighteen);
```

## Stacks
- LIFO - reverse order
- limited access DS, accessed through top
- implement functions, expression evaluation & backtracking algorithms
- visual = stack of books
- [Stack implemented via array](https://github.com/GXQ7/Java100Days/blob/master/codeSamples/MyStack.Java)

> Access & Search: **O(n)** Insertion & Deletion: **O(1)**

```JAVA
        Stack<String> stack = new Stack<String>();
        String item1Pushed = stack.push("bottom"); 
        String item2Pushed = stack.push("stack2"); 
        String item3Pushed = stack.push("stack3"); 
        String item4Pushed = stack.push("top"); 
        String topElement = stack.peek();   
        String itemRemoved = stack.pop();   
        String newTopElement = stack.peek();
        Arrays.sort(stack.toArray())
        int locationOnStack = stack.search("stack3");   
```

## Queues
- designed to hold items that don't need to be processed immediately but require FIFO processing e.g. printer spooling
- variations: dequeue, priority queue, doubly ended priority queue
- visual = line for a till
> Access & Search: **O(n)** Insertion & Deletion: **O(1)**
```JAVA
        Queue<String> q = new LinkedList<String>();
        q.add("firstInsert");
        q.add("secondInsert");   //enqueue - insertion to tail O(1)
        q.add("thirdInsert");   
        String headElement = q.element(); 
        q.remove(); //dequeue - deletion from head O(1)
        String newHead = q.element();
```
## Linked List
- a linear data structure where elements are not stored in contigious memory
- node [data, next node reference] 
- preferred over arrays due to the ease of insertion & deletion
- variations: singly linked, doubly linked, circular linked
> Access & Search: **O(n)** Insertion & Deletion: **O(1)**
```JAVA
        LinkedList<String> list = new LinkedList<String>();
        list.add("firstNode");
        list.add("secondNode");
        list.addFirst("newFirstNode");
        list.removeLast();
```

## Trees
## Tries
## Graphs (BFS and DFS)
## Hashing
## Heaps
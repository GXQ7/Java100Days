# Data Structures & Algorithms
- Recap on Java Collections & additional Data Structures and Algorithms 

![Java Collections](/images/javaCollections.png?raw=true)

# List
- an ordered collection of objects, positional access through index
- allows duplicates & any number of null values
- new methods defined in List Interface
- List can be traversed both directions using ListIterator

![List](/images/list.png?raw=true)

## Stack 
- LIFO / FILO structure where everything is acessed from the top (not easily corruptible) 
- push, peek / top, pop, isEmpty
- applications: redo & undo features in editors, navigation in web browsers, system will allocate applications stacks for running purposes & for backtracking if one path is not efficient

Implementations:
[Array]()
- + pros: easy to implement & memory saved (no pointers)
- - cons: not dynamic, won't grow & shrink according to needs at runtime

[LinkedList]()
- + pros: can grow & shrink at runtime
- - cons: extra memory for pointers

[Java's Stack Class]()
- - cons: legacy class, extra overhead of being threadsafe 

[Array Deque]()
- + more efficient for single-threaded applications

## ArrayList
- an indexable dynamic Array (fixed size, collection of the same type in contiguous memory)
```Java
        String[] customerList = new String[1];
        customerList[0] = "Megan";
        customerList[1] = "Rob";     //IndexOutOfBounds
        ArrayList<String> customerArrayList = new ArrayList<String>(10);
        customerArrayList.add("Rob");
        customerArrayList.add("Megan");
        customerArrayList.remove("Rob");
        customerArrayList.add("Eimear");
```

## Linked List
- a linear data structure where elements are not stored in contiguous memory
- node [data, next node reference] 
- used to create trees & graphs
```JAVA
        //Examples: Browsers next & previous button, undo/redo state in an application
        LinkedList<String> URLS = new LinkedList<String>();
        URLS.add("Current");
        URLS.addFirst("Back");
        URLS.add("Previous");
```

# Queue
- designed to hold items that don't need to be processed immediately but require FIFO processing

```JAVA
        Queue<String> printerQueue = new LinkedList<String>();
        printerQueue.add("Grace's Document");
        printerQueue.add("Conan's Document");
        System.out.print("Printed " + printerQueue.poll());
        System.out.print("Printing " + printerQueue.peek());
```
## Priority Queue
- queue - ordered based on priority
- Dijkstra's Shortest Path Algorithm
- PriorityBlockingQueues for thread safety 
- [Priority Queue Example](codeSamples/priorityQueue)

## ArrayDeque
- double ended queue; where you can enqueue & dequeue at both ends
```JAVA
        Deque<String> webBrowserHistory = new ArrayDeque<String>();
        webBrowserHistory.add("a");
        webBrowserHistory.offerFirst("b");
        webBrowserHistory.offerFirst("c");
        webBrowserHistory.offerFirst("d");

        if (webBrowserHistory.size() >= 3)
        {
            // URL at the tail of the deque is removed after specified number of insertions
            webBrowserHistory.removeLast();
        }
```
 
# Set
- an unordered collection of objects
- don't allow duplicate elements & only one null value
- no new methods in Set Interface; Collection Interface methods only. 
- Set can only be traveresed in a forward direction using Iterator
- aren't synchronized
- Iterator is fail fast in nature; modficiation exception if modified after Iterator creation

![Set](/images/set.png?raw=true)

## HashSet, LinkedHashSet & TreeSet
[HashSet](/codeSamples/hashSet/Hash_Set)


### Map
- (key, value) pairs; key points to value

![Map](/images/map.png?raw=true)

## HashMap, LinedHashMap & TreeMap
- built on top of array. optimised to store [key (any Type)][value] pairs
- allows the use of objects as an index, due to a hash function (key % arraySize) which returns a hashcode of where the object is stored.
- collision can occur if two objects try to occupy the same index. use a linked list to resolve.

```Java 
        HashMap<String, String> pokemonDictionary = new HashMap<String, String>();
        pokemonDictionary.put("Eevee", "(イーブイ Iibui) is a Normal-type Pokémon introduced in Generation I. It's well known for being the Pokémon with the highest number of evolution possibilities (8), due to its unstable genetic makeup");
        pokemonDictionary.put("Charizard", "(リザードン Rizaadon) is a Fire/Flying-type Pokémon introduced in Generation I.");
        pokemonDictionary.put("Darkrai", "(ダークライ Daakurai) is a Dark-type Mythical Pokémon. Cresselia is Darkrai's counterpart and rival, and together they form the Lunar Duo.");
        pokemonDictionary.put("Mew", "(ミュウ Myuu) is a Psychic-type Mythical Pokémon. Its DNA was cloned in order to create Mewtwo.");

        for (String pokemon : pokemonDictionary.keySet())
            System.out.println(pokemon); //order is not perserved
        }
        // to acces key & value
        for (Map.Entry<String, String> entry : pokemonDictionary.entrySet()) {
            System.out.println(entry.getKey() + " - " + entry.getValue());
        }
        
```

# Additional Data Structures
# Array
- an indexable, fixed size, collection of the same type in contiguous memory (primitive or reference)
- the size of the array must be known before creation
- cloning an array of Object[] results in a "deep copy" of original elements as opposed to references
> Search, Insert & Deletion: **O(n)** Sorting: **O(n log n)** Access: **O(1)**

```JAVA
        int[] ages = { 18, 35, 42, 70, 81, 67, 12, 50, 38, 40, 33 };
        String[] colours = new String[4];
        colours[0] = "Yellow";
        colours[1] = "Orange";
        colours[2] = "Green";
        colours[3] = "Blue";
        // colours[4] = "Black"; - ArrayIndexOutOfBounds = illegal index
        System.out.println(Arrays.toString(ages));
        Arrays.sort(ages);
        int index = Arrays.binarySearch(ages, 67);
    };
```

## Multi-dimensional Arrays (Jagged Arrays)
- Java supports n-dimensional arrays (can be though of as an array of elemnt array)
- Cloning of Object[][] results in a "shallow copy" a new array is created but the element arrays are referecnes to original elements

### 2D Array Implementation 
- Stored in row-major order
- [row_index][column_index]

```JAVA
        int[][] cords = { { 2, 5 }, { 6, 7 } };
        System.out.println(cords[1][1]);

        // Row-Major Order : traversal occurs across rows
        for (int i = 0; i < cords[0].length; i++) {
            for (int j = 0; j < cords.length; j++) {
                System.out.println(cords[j][i]);
            }
        }
        // Column-Major Order : traversal occurs across columns
        for (int i = 0; i < cords[0].length; i++) {
            for (int j = 0; j < cords.length; j++) {
                System.out.println(cords[j][i]);
            }
        }
```
### 3D Array Implementation 
- an array of 2D arrays
- [array_index][row_index][column_index]

- visual = array_index = spreadsheet sheet
```JAVA
        int [][][] _3dArray = {{{4,5}, {6,7}, {8,9}}    ,    {{13,15}, {18,20}, {17,68}}};
        int seven = _3dArray[0][1][1];
        int eighteen = _3dArray[1][1][0];
        System.out.println(eighteen);
```

# Trees
- when nodes point to a left & right 'child node'
- leaf - node with no children

## BST 
- BST = [root_node], [left_node] (smaller than parent) & [right_node] (greater than parent)
> Access, Search, Insertion & Deletion: average = height of tree **O(log n)** But can in the worst case scenario i.e. inserting every element from a sorted array into a bst 
## Tries 
- type of tree often used to store characters for fast look ups
- great for word validation problems 

# Graphs 




